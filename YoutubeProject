#Almost increase Sequeence
def solution(sequence):
    count_removed = 0
    for val in range(1, len(sequence)):
        if sequence[val] <= sequence[val - 1]:
            count_removed += 1
            if val > 1 and sequence[val] <= sequence[val - 2]:
                sequence[val] = sequence[val - 1]

    return count_removed <= 1


# Matrix Element sum
def solution(matrix):
    return sum(matrix[cost_rooms][free_rooms] for free_rooms in range(len(matrix[0]))   
for cost_rooms in range(len(matrix)) if matrix[cost_rooms][free_rooms]!=0 and
all(matrix[k][free_rooms] for k in range(cost_rooms)))


# All longest Strings
def solution(inputArray):
    return [words for words in inputArray if len(words) == max(len(words) for words in inputArray)]

#common Character in string
def solution(s1, s2):
    return sum(min(s1.count(char),s2.count(char)) for char in set(s1))

# isLUcky number
def isLucky(n):
    n_str = str(n)
    half_len = len(n_str) // 2
    first_half_sum = sum(int(digit) for digit in n_str[:half_len])
    second_half_sum = sum(int(digit) for digit in n_str[half_len:])
    return first_half_sum == second_half_sum

# sort by height
def solution(a):
   people=sorted([height for height in a if height!=-1])
   return [-1 if height==-1 else people.pop(0) for height in a ]

# reverse in paranthesis
def solution(inputString):
    for s in range(len(inputString)):
        if inputString[s]=='(':
            start=s
        if inputString[s]==')':
            end=s
            return solution(inputString[:start]+inputString[start+1:end][::-1]+inputString[end+1:])
    return inputString        

HACKER RANK SOLUTION
#List comprehension
if __name__ == '__main__':
    x = int(input())
    y = int(input())
    z = int(input())
    n = int(input())
    print(list([i,j,k] for i in range(x+1) for j in range(y+1) for k in range(z+1)  if i+j+k !=n))

#Check Leap Year
def is_leap(year):
    leap = False
    # Write your logic here
    if year%4==0:
        leap=True
        if year%100==0:
            if year%400==0:
                leap= True
            else:
                leap=False    
    return leap

# find ruunner up_score
if __name__ == '__main__':
    n = int(input())
    arr = map(int, input().split())
    print(sorted(set(arr),reverse=True)[1])

#swap_Case
def swap_case(s):
    return s.swapcase()
#list operation
f __name__ == '__main__':
    N = int(input())
    L=[]
    for i in range(0,N):
        cmd=input().split()
        if cmd[0]=='insert':
            L.insert(int(cmd[1]),int(cmd[2]))
        elif cmd[0]=='append':
            L.append(int(cmd[1]))
        elif cmd[0]=='pop':
            L.pop()    
        elif cmd[0]=='print':
            print(L)
        elif cmd[0]=='remove':
            L.remove(int(cmd[1]))    
        elif cmd[0]=='sort':
            L.sort()
        else:
            L.reverse()  
#Neste List
if __name__ == '__main__':
    a_list=[]
    for _ in range(int(input())):
        name = input()
        score = float(input())
        a_list.append([name,score])
    second_high=sorted(set([score for name,score in a_list]))[1]
    print('\n'.join(sorted([name for name,score in a_list if score==second_high])))

# string mutation
def mutate_string(string, position, character):
    n=list(string)
    n[position]=character
    string=''.join(n)
    return string

#Find Percentage
if __name__ == '__main__':
    n = int(input())
    student_marks = {}
    for _ in range(n):
        name, *line = input().split()
        scores = list(map(float, line))
        student_marks[name] = scores
    query_name = input()
    l=list(student_marks[query_name])
    result=sum(l)/len(l)
    print('%.2f'%result)

#String validator
if __name__ == '__main__':
    s = input()
    print(any(c.isalnum() for c in s))
    print(any(c.isalpha()   for c in s)) 
    print(any(c.isdigit() for c in s))
    print(any(c.lower()   for c in s))
    print(any(c.upper()   for c in s))

#Text Alignment
thickness = int(input()) #This must be an odd number
c = 'H'

#Top Cone
for i in range(thickness):
    print((c*i).rjust(thickness-1)+c+(c*i).ljust(thickness-1))
#Top Pillars
for i in range(thickness+1):
    print((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6))
#Middle Belt
for i in range((thickness+1)//2):
    print((c*thickness*5).center(thickness*6))    
#Bottom Pillars
for i in range(thickness+1):
    print((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6))    
#Bottom Cone
for i in range(thickness):
    print(((c*(thickness-i-1)).rjust(thickness)+c+(c*(thickness-i-1)).ljust(thickness)).rjust(thickness*6))

#text wrap
import textwrap
def wrap(string, max_width):
    return textwrap.fill(string,width=max_width)
if __name__ == '__main__':
    string, max_width = input(), int(input())
    result = wrap(string, max_width)
    print(result)

#design door mat
N,M=map(int,input().split())
for dots in range(N//2):
      j = int((2*dots)+1)
      print(('.|.'*j).center(M, '-'))
print('WELCOME'.center(M,'-'))
for i in reversed(range(N//2)):
    j = int((2*i)+1)
    print(('.|.'*j).center(M, '-'))

#captilize name
def solve(s):
    ans=s.split(' ')
    ans1=(((i.capitalize() for i in ans)))
    return ' '.join(ans1)

#minion game
 n = len(string)
    comb = ((n)*(n+1))/2
    count_k = 0
    count_s = 0
    count_k = sum([len(string[i:]) for i in range(len(string)) if string[i] in "AEIOU"])
    count_s = comb - count_k
    if count_s == count_k:
        print("Draw")
    elif count_s > count_k:
        print("Stuart", int(count_s) )
    else:
        print("Kevin", int(count_k))

#triangle quest
or i in range(1,int(input())+1): #More than 2 lines will result in 0 score. Do not leave a blank line also
    print (((10**i)//9)**2)

#OrderdDict
from collections import OrderedDict
input_=int(input())
a=OrderedDict()
for _ in range(input_):
    item,name,price=input().rpartition(' ')
    a[item]=a.get(item,0)+int(price)
for item,price in a.items():
    print(item,price)

#word Orderd
from collections import Counter
n=int(input())
l1=[input().strip() for _ in range(n)]
result=Counter(l1)
print(len(result))
print(*result.values())

#Collection DEQueue
from collections import deque
D=deque()
for _ in range(int(input())):
    op,val,*args=input().split()+['']
    eval(f'D.{op}({val})')
print(*D)  

#iterable iteration
from itertools import combinations
N=int(input())
L=input().split()
K=int(input())
C=list(combinations(L,K))
F=filter(lambda c :'a' in c,C)
print('{0:.3}'.format(len(list(F))/len(C)))

# divmod
a=int(input())
b=int(input())
print(a//b)
print(a%b)
print(divmod(a,b))

#power mod
a=int(input())
b=int(input())
m=int(input())
C=pow(a,b)
D=C%m
print(int(C))
print(int(D))

#integer come all side
a=int(input())
b=int(input())
c=int(input())
d=int(input())

print(int(pow(a, b))+ int(pow(c, d)))

#check subset
for i in range(int(input())):
    a=int(input())
    set_a=set(map(int, input().split()))
    b=int(input())
    set_b=set(map(int, input().split()))
    if len(set_a.difference(set_b))==0:
        print('True')
    else:
        print('False')

#strict subset
A = set(input().split())
COUNT = 0
VALUE = 0
for i in range(int(input())):
    if A.issuperset(set(input().split())):
        COUNT += 1
    else:
        VALUE += 1
if VALUE != 0:
    print('False')
else:
    print('True')

#Torison angle
import math

class Points(object):
    def __init__(self, x, y, z):
        self.x=x
        self.y=y
        self.z=z

    def __sub__(self, no):
        return Points((self.x-no.x), (self.y-no.y), (self.z-no.z))
         
    def dot(self, no):
        return (self.x*no.x)+(self.y*no.y)+(self.z*no.z)

    def cross(self, no):
        return Points((self.y*no.z-self.z*no.y), (self.z*no.x-self.x*no.z), (self.x*no.y-self.y*no.x))
        
    def absolute(self):
        return pow((self.x ** 2 + self.y ** 2 + self.z ** 2), 0.5)

#set.discord(),pop(),remove()
n = int(input())
s = set(map(int, input().split()))
for i in range(int(input())):
    s1=input().split()
    if s1[0]=='pop':
        s.pop()
    elif s1[0]=='remove':
        s.remove(int(s1[1]))
    elif s1[0]=='discard':
        s.discard(int(s1[1]))
print(sum(s)) 

#set union 
m=int(input())
eng_n=set(input().split())
n=int(input())
fre_n=set(input().split())
print(len(eng_n.union(fre_n)))

#set mutation
len_set=int(input())
storage=set(map(int,input().split()))
op_list=int(input())

for i in range(op_list):
    operation=input().split()
    
    if operation[0]=='intersection_update':
        temp_storage=set(map(int, input().split()))
        storage.intersection_update(temp_storage)
    elif operation[0] =='update':
        temp_storage=set(map(int, input().split()))
        storage.update(temp_storage)     
    elif operation[0]=='symmetric_difference_update':
        temp_storage=set(map(int, input().split()))
        storage.symmetric_difference_update(temp_storage)
    elif operation[0]=='difference_update':
        temp_storage=set(map(int, input().split()))
        storage.difference_update(temp_storage)
    else:
        assert False
print(sum(storage))                        

#zipped
N, X= input().split()
io=list()
for _ in range(int(X)):
    ip=map(float, input().split())
    io.append(ip)
for i in zip(*io):
    print(sum(i)/len(i))

#input()
f __name__=='__main__':
    x, k= map(int, input().strip().split())
    string=input().strip()
    
    if eval(string)==k:
        print('True')
    else:
        print('False')

#Any or All
_=input()
n=input().split()
print(all([int(i)>0 for i in n]) and any([j==j[::-1] for j in n]))

#Detect Float 
import re
pattern=re.compile('^[-+]?[0-9]*\.[0-9]+$')
for _ in range(int(input())):
    print(bool(pattern.match(input())))

    
        

                
    




